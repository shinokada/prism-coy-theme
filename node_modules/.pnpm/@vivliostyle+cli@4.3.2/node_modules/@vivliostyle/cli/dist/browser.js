"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadBrowser = exports.checkBrowserAvailability = exports.getExecutableBrowserPath = exports.launchBrowser = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const perf_hooks_1 = require("perf_hooks");
const puppeteer_core_1 = __importDefault(require("puppeteer-core"));
const container_1 = require("./container");
const util_1 = require("./util");
async function launchBrowser(options) {
    // process listener of puppeteer won't handle signal
    // because it doesn't support subprocess which is spawned by CLI
    const browser = await puppeteer_core_1.default.launch({
        handleSIGINT: false,
        handleSIGTERM: false,
        handleSIGHUP: false,
        ...options,
    });
    util_1.beforeExitHandlers.push(() => {
        browser.close();
    });
    return browser;
}
exports.launchBrowser = launchBrowser;
function getExecutableBrowserPath() {
    const isInContainer = container_1.checkContainerEnvironment();
    if (isInContainer && os_1.default.arch() === 'arm64') {
        // Use the Debian packages until puppeteer supports
        // https://github.com/puppeteer/puppeteer/blob/159d2835450697dabea6f9adf6e67d158b5b8ae3/src/node/BrowserFetcher.ts#L298-L303
        return '/usr/bin/chromium';
    }
    return puppeteer_core_1.default.executablePath();
}
exports.getExecutableBrowserPath = getExecutableBrowserPath;
function checkBrowserAvailability(path) {
    return fs_1.default.existsSync(path);
}
exports.checkBrowserAvailability = checkBrowserAvailability;
async function downloadBrowser() {
    const browserFetcher = puppeteer_core_1.default.createBrowserFetcher({});
    const revision = puppeteer_core_1.default._preferredRevision;
    const revisionInfo = browserFetcher.revisionInfo(revision);
    util_1.debug('trying download browser, revision info', revisionInfo);
    const toMegabytes = (bytes) => `${(bytes / 1024 / 1024).toFixed(1)} Mb`;
    let time = perf_hooks_1.performance.now();
    const onProgress = (downloadedBytes, totalBytes) => {
        const now = perf_hooks_1.performance.now();
        if (now - time < 100) {
            return;
        }
        time = now;
        const progressLen = 16;
        const completeLen = Math.round((downloadedBytes / totalBytes) * progressLen);
        const progressBar = `[${Array(completeLen + 1).join('=')}${Array(progressLen - completeLen + 1).join(' ')}]`;
        util_1.logUpdate(`Downloading Browser: ${progressBar} ${toMegabytes(downloadedBytes)} / ${toMegabytes(totalBytes)}`);
    };
    util_1.logInfo('Rendering browser (Chromium) is not installed yet. Downloading now...');
    util_1.startLogging('Downloading Browser');
    await browserFetcher.download(revision, onProgress);
    util_1.logSuccess(`Successfully downloaded browser`);
    util_1.startLogging();
    return revisionInfo.executablePath;
}
exports.downloadBrowser = downloadBrowser;
//# sourceMappingURL=browser.js.map