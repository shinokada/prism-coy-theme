"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUrlString = exports.pathStartsWith = exports.touchTmpFile = exports.useTmpDirectory = exports.inflateZip = exports.statFile = exports.readJSON = exports.gracefulError = exports.logInfo = exports.logError = exports.logSuccess = exports.logUpdate = exports.log = exports.stopLogging = exports.startLogging = exports.beforeExitHandlers = exports.cwd = exports.debug = void 0;
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const node_stream_zip_1 = __importDefault(require("node-stream-zip"));
const ora_1 = __importDefault(require("ora"));
const shelljs_1 = __importDefault(require("shelljs"));
const tmp_1 = __importDefault(require("tmp"));
const upath_1 = __importDefault(require("upath"));
const util_1 = __importDefault(require("util"));
exports.debug = debug_1.default('vs-cli');
exports.cwd = upath_1.default.normalize(process.cwd());
const ora = ora_1.default({ color: 'blue', spinner: 'circle' });
exports.beforeExitHandlers = [];
const exitSignals = ['exit', 'SIGINT', 'SIGTERM', 'SIGHUP'];
exitSignals.forEach((sig) => {
    process.on(sig, (code) => {
        var _a;
        while (exports.beforeExitHandlers.length) {
            try {
                (_a = exports.beforeExitHandlers.shift()) === null || _a === void 0 ? void 0 : _a();
            }
            catch (e) {
                // NOOP
            }
        }
        process.exit(code);
    });
});
function startLogging(text) {
    ora.start(text);
}
exports.startLogging = startLogging;
function stopLogging(text, symbol) {
    if (!text) {
        ora.stop();
        return;
    }
    ora.stopAndPersist({ text, symbol });
}
exports.stopLogging = stopLogging;
function log(...obj) {
    console.log(...obj);
}
exports.log = log;
function logUpdate(...obj) {
    ora.text = obj.join(' ');
}
exports.logUpdate = logUpdate;
function logSuccess(...obj) {
    ora.succeed(obj.join(' '));
}
exports.logSuccess = logSuccess;
function logError(...obj) {
    ora.fail(obj.join(' '));
}
exports.logError = logError;
function logInfo(...obj) {
    ora.info(obj.join(' '));
}
exports.logInfo = logInfo;
function gracefulError(err) {
    const message = err.stack
        ? err.stack.replace(/^Error:/, chalk_1.default.red.bold('Error:'))
        : `${chalk_1.default.red.bold('Error:')} ${err.message}`;
    if (ora.isSpinning) {
        ora.fail(message);
    }
    else {
        console.error(message);
    }
    console.log(chalk_1.default.gray(`
If you think this is a bug, please report at https://github.com/vivliostyle/vivliostyle-cli/issues`));
    process.exit(1);
}
exports.gracefulError = gracefulError;
function readJSON(path) {
    try {
        return JSON.parse(fs_1.default.readFileSync(path, 'utf8'));
    }
    catch (err) {
        return undefined;
    }
}
exports.readJSON = readJSON;
async function statFile(filePath) {
    try {
        return util_1.default.promisify(fs_1.default.stat)(filePath);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error(`Specified input doesn't exists: ${filePath}`);
        }
        throw err;
    }
}
exports.statFile = statFile;
async function inflateZip(filePath, dest) {
    return await new Promise((res, rej) => {
        try {
            const zip = new node_stream_zip_1.default({
                file: filePath,
                storeEntries: true,
            });
            zip.on('error', (err) => {
                rej(err);
            });
            zip.on('ready', async () => {
                await util_1.default.promisify(zip.extract)(null, dest);
                await util_1.default.promisify(zip.close)();
                exports.debug(`Unzipped ${filePath} to ${dest}`);
                res();
            });
        }
        catch (err) {
            rej(err);
        }
    });
}
exports.inflateZip = inflateZip;
function useTmpDirectory() {
    return new Promise((res, rej) => {
        tmp_1.default.dir({ unsafeCleanup: true }, (err, path, clear) => {
            if (err) {
                return rej(err);
            }
            exports.debug(`Created the temporary directory: ${path}`);
            const callback = () => {
                // clear function doesn't work well?
                // clear();
                shelljs_1.default.rm('-rf', path);
                exports.debug(`Removed the temporary directory: ${path}`);
            };
            exports.beforeExitHandlers.push(callback);
            res([path, callback]);
        });
    });
}
exports.useTmpDirectory = useTmpDirectory;
async function touchTmpFile(path) {
    shelljs_1.default.touch(path);
    exports.debug(`Created the temporary file: ${path}`);
    const callback = () => {
        shelljs_1.default.rm('-f', path);
        exports.debug(`Removed the temporary file: ${path}`);
    };
    exports.beforeExitHandlers.push(callback);
    return callback;
}
exports.touchTmpFile = touchTmpFile;
function pathStartsWith(path1, path2) {
    const path1n = upath_1.default.normalize(path1).replace(/\/?$/, '/');
    const path2n = upath_1.default.normalize(path2).replace(/\/?$/, '/');
    return path1n.startsWith(path2n);
}
exports.pathStartsWith = pathStartsWith;
function isUrlString(str) {
    return /^(https?|file|data):/i.test(str);
}
exports.isUrlString = isUrlString;
//# sourceMappingURL=util.js.map