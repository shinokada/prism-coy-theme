"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportWebPublication = void 0;
const fs_1 = __importDefault(require("fs"));
const globby_1 = __importDefault(require("globby"));
const shelljs_1 = __importDefault(require("shelljs"));
const upath_1 = __importDefault(require("upath"));
const util_1 = require("./util");
async function exportWebPublication({ exportAliases, manifestPath, input, output, }) {
    if (fs_1.default.existsSync(output)) {
        util_1.debug('going to remove existing webpub', output);
        shelljs_1.default.rm('-rf', output);
    }
    const silentMode = shelljs_1.default.config.silent;
    shelljs_1.default.config.silent = true;
    try {
        const relExportAliases = exportAliases
            .map(({ source, target }) => ({
            source: upath_1.default.relative(input, source),
            target: upath_1.default.relative(input, target),
        }))
            .filter(({ source }) => !source.startsWith('..'));
        const files = [
            ...(await globby_1.default('**/*', {
                cwd: input,
                // copy files included on exportAlias in last
                ignore: relExportAliases.map(({ source }) => source),
                followSymbolicLinks: false,
                gitignore: true,
            })),
        ];
        util_1.debug('webbook files', files);
        for (const file of files) {
            const target = upath_1.default.join(output, file);
            const stderr = shelljs_1.default.mkdir('-p', upath_1.default.dirname(target)).stderr ||
                shelljs_1.default.cp('-r', upath_1.default.join(input, file), target).stderr;
            if (stderr) {
                throw new Error(stderr);
            }
        }
        util_1.debug('webbook files (alias)', relExportAliases);
        let actualManifestPath = manifestPath;
        for (const entry of relExportAliases) {
            const target = upath_1.default.join(output, entry.target);
            const stderr = shelljs_1.default.mkdir('-p', upath_1.default.dirname(target)).stderr ||
                shelljs_1.default.cp('-r', upath_1.default.join(input, entry.source), target).stderr;
            if (stderr) {
                throw new Error(stderr);
            }
            if (upath_1.default.join(input, entry.source) === manifestPath) {
                actualManifestPath = target;
            }
        }
        util_1.debug('webbook publication.json', actualManifestPath);
        // Overwrite copied publication.json
        const manifest = JSON.parse(fs_1.default.readFileSync(actualManifestPath, 'utf8'));
        for (const entry of relExportAliases) {
            const rewriteAliasPath = (e) => {
                if (typeof e === 'string') {
                    return e === entry.source ? entry.source : e;
                }
                if (e.url === entry.source) {
                    e.url = entry.target;
                }
                return e;
            };
            if (manifest.links) {
                manifest.links = Array.isArray(manifest.links)
                    ? manifest.links.map(rewriteAliasPath)
                    : rewriteAliasPath(manifest.links);
            }
            if (manifest.readingOrder) {
                manifest.readingOrder = Array.isArray(manifest.readingOrder)
                    ? manifest.readingOrder.map(rewriteAliasPath)
                    : rewriteAliasPath(manifest.readingOrder);
            }
            if (manifest.resources) {
                manifest.resources = Array.isArray(manifest.resources)
                    ? manifest.resources.map(rewriteAliasPath)
                    : rewriteAliasPath(manifest.resources);
            }
        }
        fs_1.default.writeFileSync(actualManifestPath, JSON.stringify(manifest, null, 2));
    }
    catch (err) {
        shelljs_1.default.rm('-rf', output);
        throw err;
    }
    finally {
        shelljs_1.default.config.silent = silentMode;
    }
    return output;
}
exports.exportWebPublication = exportWebPublication;
//# sourceMappingURL=webbook.js.map