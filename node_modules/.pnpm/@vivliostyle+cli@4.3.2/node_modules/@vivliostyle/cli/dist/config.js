"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUnusedCliFlags = exports.mergeConfig = exports.collectVivliostyleConfig = exports.parseTheme = exports.contextResolve = exports.validateTimeoutFlag = void 0;
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const chalk_1 = __importDefault(require("chalk"));
const cheerio_1 = __importDefault(require("cheerio"));
const fs_1 = __importDefault(require("fs"));
const resolve_pkg_1 = __importDefault(require("resolve-pkg"));
const upath_1 = __importDefault(require("upath"));
const url_1 = require("url");
const browser_1 = require("./browser");
const const_1 = require("./const");
const container_1 = require("./container");
const epub_1 = require("./epub");
const input_1 = require("./input");
const markdown_1 = require("./markdown");
const output_1 = require("./output");
const vivliostyle_config_schema_json_1 = __importDefault(require("./schema/vivliostyle.config.schema.json"));
const util_1 = require("./util");
const DEFAULT_TIMEOUT = 2 * 60 * 1000; // 2 minutes
const DEFAULT_ASSETS = [
    '**/*.png',
    '**/*.jpg',
    '**/*.jpeg',
    '**/*.svg',
    '**/*.gif',
    '**/*.webp',
    '**/*.apng',
    '**/*.ttf',
    '**/*.otf',
    '**/*.woff',
    '**/*.woff2',
];
function validateTimeoutFlag(val) {
    return Number.isFinite(+val) && +val > 0 ? +val * 1000 : DEFAULT_TIMEOUT;
}
exports.validateTimeoutFlag = validateTimeoutFlag;
function contextResolve(context, loc) {
    return loc && upath_1.default.resolve(context, loc);
}
exports.contextResolve = contextResolve;
function normalizeEntry(e) {
    if (typeof e === 'object') {
        return e;
    }
    return { path: e };
}
// parse theme locator
function parseTheme(locator, contextDir, workspaceDir) {
    if (typeof locator !== 'string' || locator == '') {
        return undefined;
    }
    // url
    if (util_1.isUrlString(locator)) {
        return {
            type: 'uri',
            name: upath_1.default.basename(locator),
            location: locator,
        };
    }
    const stylePath = upath_1.default.resolve(contextDir, locator);
    // node_modules, local pkg
    const pkgRootDir = resolve_pkg_1.default(locator, { cwd: contextDir });
    if (!(pkgRootDir === null || pkgRootDir === void 0 ? void 0 : pkgRootDir.endsWith('.css'))) {
        const style = parseStyleLocator(pkgRootDir !== null && pkgRootDir !== void 0 ? pkgRootDir : stylePath, locator);
        if (style) {
            return {
                type: 'package',
                name: style.name,
                location: pkgRootDir !== null && pkgRootDir !== void 0 ? pkgRootDir : stylePath,
                destination: upath_1.default.join(workspaceDir, 'themes/packages', style.name),
                style: style.maybeStyle,
            };
        }
    }
    // bare .css file
    const sourceRelPath = upath_1.default.relative(contextDir, stylePath);
    return {
        type: 'file',
        name: upath_1.default.basename(locator),
        location: stylePath,
        destination: upath_1.default.resolve(workspaceDir, sourceRelPath),
    };
}
exports.parseTheme = parseTheme;
function parseStyleLocator(pkgRootDir, locator) {
    var _a, _b, _c, _d;
    const pkgJsonPath = upath_1.default.join(pkgRootDir, 'package.json');
    if (!fs_1.default.existsSync(pkgJsonPath)) {
        return undefined;
    }
    const packageJson = JSON.parse(fs_1.default.readFileSync(pkgJsonPath, 'utf8'));
    const maybeStyle = (_d = (_c = (_b = (_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.vivliostyle) === null || _a === void 0 ? void 0 : _a.theme) === null || _b === void 0 ? void 0 : _b.style) !== null && _c !== void 0 ? _c : packageJson.style) !== null && _d !== void 0 ? _d : packageJson.main;
    if (!maybeStyle) {
        throw new Error(`invalid style file: ${maybeStyle} while parsing ${locator}`);
    }
    return { name: packageJson.name, maybeStyle };
}
function parsePageSize(size) {
    const [width, height, ...others] = `${size}`.split(',');
    if (others.length) {
        throw new Error(`Cannot parse size: ${size}`);
    }
    else if (width && height) {
        return {
            width,
            height,
        };
    }
    else {
        return {
            format: width !== null && width !== void 0 ? width : 'Letter',
        };
    }
}
function parseFileMetadata(type, sourcePath, workspaceDir) {
    var _a, _b, _c;
    const sourceDir = upath_1.default.dirname(sourcePath);
    let title;
    let theme;
    if (type === 'text/markdown') {
        const metadata = markdown_1.readMarkdownMetadata(sourcePath);
        title = metadata.title;
        theme = parseTheme((_a = metadata.vfm) === null || _a === void 0 ? void 0 : _a.theme, sourceDir, workspaceDir);
    }
    else {
        const $ = cheerio_1.default.load(fs_1.default.readFileSync(sourcePath, 'utf8'));
        title = (_c = (_b = $('title')) === null || _b === void 0 ? void 0 : _b.text()) !== null && _c !== void 0 ? _c : undefined;
    }
    return { title, theme };
}
function collectVivliostyleConfig(cliFlags) {
    const load = (configPath) => {
        if (!fs_1.default.existsSync(configPath)) {
            return undefined;
        }
        delete require.cache[configPath]; // clear require cache
        const config = require(configPath);
        const ajv = new ajv_1.default({ strict: false });
        ajv_formats_1.default(ajv);
        const valid = ajv.validate(vivliostyle_config_schema_json_1.default, config);
        if (!valid) {
            throw new Error(`Validation of vivliostyle.config failed. Please check the schema: ${configPath}`);
        }
        return config;
    };
    let vivliostyleConfigPath = cliFlags.configPath
        ? upath_1.default.resolve(util_1.cwd, cliFlags.configPath)
        : upath_1.default.join(util_1.cwd, 'vivliostyle.config.js');
    let vivliostyleConfig = load(vivliostyleConfigPath);
    if (!vivliostyleConfig &&
        cliFlags.input &&
        upath_1.default.basename(cliFlags.input).startsWith('vivliostyle.config')) {
        // Load an input argument as a Vivliostyle config
        try {
            const inputPath = upath_1.default.resolve(util_1.cwd, cliFlags.input);
            const inputConfig = load(inputPath);
            if (inputConfig) {
                cliFlags = {
                    ...cliFlags,
                    input: undefined,
                };
                vivliostyleConfigPath = inputPath;
                vivliostyleConfig = inputConfig;
            }
        }
        catch (_err) { }
    }
    return {
        cliFlags,
        vivliostyleConfig,
        vivliostyleConfigPath,
    };
}
exports.collectVivliostyleConfig = collectVivliostyleConfig;
async function mergeConfig(cliFlags, config, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    util_1.debug('context directory', context);
    util_1.debug('cliFlags', cliFlags);
    util_1.debug('vivliostyle.config.js', config);
    let entryContextDir;
    let workspaceDir;
    if (cliFlags.input && util_1.isUrlString(cliFlags.input)) {
        workspaceDir = entryContextDir = util_1.cwd;
    }
    else {
        entryContextDir = upath_1.default.resolve(cliFlags.input
            ? upath_1.default.dirname(upath_1.default.resolve(context, cliFlags.input))
            : (_a = contextResolve(context, config === null || config === void 0 ? void 0 : config.entryContext)) !== null && _a !== void 0 ? _a : context);
        workspaceDir =
            (_b = contextResolve(context, config === null || config === void 0 ? void 0 : config.workspaceDir)) !== null && _b !== void 0 ? _b : entryContextDir;
    }
    const includeAssets = (config === null || config === void 0 ? void 0 : config.includeAssets)
        ? Array.isArray(config.includeAssets)
            ? config.includeAssets
            : [config.includeAssets]
        : DEFAULT_ASSETS;
    const language = (_d = (_c = cliFlags.language) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.language) !== null && _d !== void 0 ? _d : null;
    const sizeFlag = (_e = cliFlags.size) !== null && _e !== void 0 ? _e : config === null || config === void 0 ? void 0 : config.size;
    const size = sizeFlag ? parsePageSize(sizeFlag) : undefined;
    const customStyle = cliFlags.style &&
        (util_1.isUrlString(cliFlags.style)
            ? cliFlags.style
            : url_1.pathToFileURL(cliFlags.style).href);
    const customUserStyle = cliFlags.userStyle &&
        (util_1.isUrlString(cliFlags.userStyle)
            ? cliFlags.userStyle
            : url_1.pathToFileURL(cliFlags.userStyle).href);
    const singleDoc = (_f = cliFlags.singleDoc) !== null && _f !== void 0 ? _f : false;
    const quick = (_g = cliFlags.quick) !== null && _g !== void 0 ? _g : false;
    const cover = (_h = contextResolve(entryContextDir, config === null || config === void 0 ? void 0 : config.cover)) !== null && _h !== void 0 ? _h : undefined;
    const pressReady = (_k = (_j = cliFlags.pressReady) !== null && _j !== void 0 ? _j : config === null || config === void 0 ? void 0 : config.pressReady) !== null && _k !== void 0 ? _k : false;
    const renderMode = (_l = cliFlags.renderMode) !== null && _l !== void 0 ? _l : 'local';
    const preflight = (_m = cliFlags.preflight) !== null && _m !== void 0 ? _m : (pressReady ? 'press-ready' : null);
    const preflightOption = (_o = cliFlags.preflightOption) !== null && _o !== void 0 ? _o : [];
    const vfmOptions = {
        hardLineBreaks: (_q = (_p = config === null || config === void 0 ? void 0 : config.vfm) === null || _p === void 0 ? void 0 : _p.hardLineBreaks) !== null && _q !== void 0 ? _q : false,
        disableFormatHtml: (_s = (_r = config === null || config === void 0 ? void 0 : config.vfm) === null || _r === void 0 ? void 0 : _r.disableFormatHtml) !== null && _s !== void 0 ? _s : false,
    };
    const verbose = (_t = cliFlags.verbose) !== null && _t !== void 0 ? _t : false;
    const timeout = (_v = (_u = cliFlags.timeout) !== null && _u !== void 0 ? _u : config === null || config === void 0 ? void 0 : config.timeout) !== null && _v !== void 0 ? _v : DEFAULT_TIMEOUT;
    const sandbox = (_w = cliFlags.sandbox) !== null && _w !== void 0 ? _w : true;
    const executableChromium = (_x = cliFlags.executableChromium) !== null && _x !== void 0 ? _x : browser_1.getExecutableBrowserPath();
    const image = (_z = (_y = cliFlags.image) !== null && _y !== void 0 ? _y : config === null || config === void 0 ? void 0 : config.image) !== null && _z !== void 0 ? _z : container_1.CONTAINER_IMAGE;
    const themeIndexes = [];
    const rootTheme = (_0 = parseTheme(cliFlags.theme, util_1.cwd, workspaceDir)) !== null && _0 !== void 0 ? _0 : parseTheme(config === null || config === void 0 ? void 0 : config.theme, context, workspaceDir);
    if (rootTheme) {
        themeIndexes.push(rootTheme);
    }
    const outputs = (() => {
        var _a;
        if ((_a = cliFlags.targets) === null || _a === void 0 ? void 0 : _a.length) {
            return cliFlags.targets.map(({ path: outputPath, format }) => {
                if (format === 'pdf') {
                    return {
                        path: upath_1.default.resolve(outputPath),
                        format,
                        renderMode,
                        preflight,
                        preflightOption,
                    };
                }
                else {
                    return {
                        path: upath_1.default.resolve(outputPath),
                        format,
                    };
                }
            });
        }
        if (config === null || config === void 0 ? void 0 : config.output) {
            return (Array.isArray(config.output)
                ? config.output
                : [config.output]).map((target) => {
                var _a, _b, _c, _d;
                const targetObj = typeof target === 'string' ? { path: target } : target;
                const outputPath = upath_1.default.resolve(context, targetObj.path);
                const format = (_a = targetObj.format) !== null && _a !== void 0 ? _a : output_1.detectOutputFormat(outputPath);
                if (!output_1.checkOutputFormat(format)) {
                    throw new Error(`Unknown format: ${format}`);
                }
                if (format === 'pdf') {
                    const outputRenderMode = (_b = targetObj.renderMode) !== null && _b !== void 0 ? _b : renderMode;
                    const outputPreflight = (_c = targetObj.preflight) !== null && _c !== void 0 ? _c : preflight;
                    if (!output_1.checkRenderMode(outputRenderMode)) {
                        throw new Error(`Unknown renderMode: ${outputRenderMode}`);
                    }
                    if (outputPreflight !== null &&
                        !output_1.checkPreflightMode(outputPreflight)) {
                        throw new Error(`Unknown preflight: ${outputPreflight}`);
                    }
                    return {
                        ...targetObj,
                        path: outputPath,
                        format,
                        renderMode: outputRenderMode,
                        preflight: outputPreflight,
                        preflightOption: (_d = targetObj.preflightOption) !== null && _d !== void 0 ? _d : preflightOption,
                    };
                }
                else {
                    return { ...targetObj, path: outputPath, format };
                }
            });
        }
        // Outputs a pdf file if any output configuration is not set
        const filename = (config === null || config === void 0 ? void 0 : config.title) ? `${config.title}.pdf` : 'output.pdf';
        return [
            {
                path: upath_1.default.resolve(context, filename),
                format: 'pdf',
                renderMode,
                preflight,
                preflightOption,
            },
        ];
    })();
    const commonOpts = {
        entryContextDir,
        workspaceDir,
        includeAssets,
        outputs,
        themeIndexes,
        size,
        customStyle,
        customUserStyle,
        singleDoc,
        quick,
        language,
        vfmOptions,
        cover,
        verbose,
        timeout,
        sandbox,
        executableChromium,
        image,
    };
    if (!cliFlags.input && !config) {
        throw new Error('No input is set. Please set an appropriate entry or a Vivliostyle config file.');
    }
    const parsedConfig = cliFlags.input
        ? await composeSingleInputConfig(commonOpts, cliFlags, config)
        : await composeProjectConfig(commonOpts, cliFlags, config, context);
    util_1.debug('parsedConfig', parsedConfig);
    checkUnusedCliFlags(parsedConfig, cliFlags);
    return parsedConfig;
}
exports.mergeConfig = mergeConfig;
async function composeSingleInputConfig(otherConfig, cliFlags, config) {
    var _a;
    util_1.debug('entering single entry config mode');
    let sourcePath;
    let workspaceDir;
    let input;
    const entries = [];
    const exportAliases = [];
    const tmpPrefix = `.vs-${Date.now()}.`;
    if (cliFlags.input && util_1.isUrlString(cliFlags.input)) {
        sourcePath = cliFlags.input;
        workspaceDir = otherConfig.workspaceDir;
        input = { format: 'webbook', entry: sourcePath };
    }
    else {
        sourcePath = upath_1.default.resolve(cliFlags.input);
        workspaceDir = upath_1.default.dirname(sourcePath);
        input = input_1.detectInputFormat(sourcePath);
    }
    if (input.format === 'markdown') {
        // Single input file; create temporary file
        const type = input_1.detectManuscriptMediaType(sourcePath);
        const metadata = parseFileMetadata(type, sourcePath, workspaceDir);
        const target = upath_1.default
            .resolve(workspaceDir, `${tmpPrefix}${upath_1.default.basename(sourcePath)}`)
            .replace(/\.md$/, '.html');
        await util_1.touchTmpFile(target);
        entries.push({
            type,
            source: sourcePath,
            target,
            title: metadata.title,
            theme: (_a = metadata.theme) !== null && _a !== void 0 ? _a : otherConfig.themeIndexes[0],
        });
        exportAliases.push({
            source: target,
            target: upath_1.default.resolve(workspaceDir, upath_1.default.basename(sourcePath).replace(/\.md$/, '.html')),
        });
    }
    const manifestDeclaration = await (async () => {
        var _a, _b, _c, _d;
        if (input.format === 'markdown') {
            // create temporary manifest file
            const manifestPath = upath_1.default.resolve(workspaceDir, `${tmpPrefix}${const_1.MANIFEST_FILENAME}`);
            await util_1.touchTmpFile(manifestPath);
            exportAliases.push({
                source: manifestPath,
                target: upath_1.default.resolve(workspaceDir, const_1.MANIFEST_FILENAME),
            });
            return {
                manifestPath,
                manifestAutoGenerate: {
                    title: (_b = (_a = cliFlags.title) !== null && _a !== void 0 ? _a : config === null || config === void 0 ? void 0 : config.title) !== null && _b !== void 0 ? _b : (entries.length === 1 && entries[0].title
                        ? entries[0].title
                        : upath_1.default.basename(sourcePath)),
                    author: (_d = (_c = cliFlags.author) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.author) !== null && _d !== void 0 ? _d : '',
                },
            };
        }
        else if (input.format === 'html' || input.format === 'webbook') {
            return { webbookEntryPath: input.entry };
        }
        else if (input.format === 'pub-manifest') {
            return { manifestPath: input.entry, manifestAutoGenerate: null };
        }
        else if (input.format === 'epub-opf') {
            return { epubOpfPath: input.entry };
        }
        else if (input.format === 'epub') {
            const { epubOpfPath } = await epub_1.openEpubToTmpDirectory(input.entry);
            return { epubOpfPath };
        }
        else {
            throw new Error('Failed to export manifest declaration');
        }
    })();
    return {
        ...otherConfig,
        ...manifestDeclaration,
        entries,
        input,
        exportAliases,
    };
}
async function composeProjectConfig(otherConfig, cliFlags, config, context) {
    var _a, _b, _c, _d, _e;
    util_1.debug('entering project config mode');
    const { entryContextDir, workspaceDir, themeIndexes, outputs } = otherConfig;
    const pkgJsonPath = upath_1.default.resolve(context, 'package.json');
    const pkgJson = fs_1.default.existsSync(pkgJsonPath)
        ? util_1.readJSON(pkgJsonPath)
        : undefined;
    if (pkgJson) {
        util_1.debug('located package.json path', pkgJsonPath);
    }
    const autoGeneratedTocPath = upath_1.default.resolve(workspaceDir, typeof (config === null || config === void 0 ? void 0 : config.toc) === 'string' ? config.toc : const_1.TOC_FILENAME);
    const projectTitle = (_b = (_a = cliFlags.title) !== null && _a !== void 0 ? _a : config === null || config === void 0 ? void 0 : config.title) !== null && _b !== void 0 ? _b : pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.name;
    const projectAuthor = (_d = (_c = cliFlags.author) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.author) !== null && _d !== void 0 ? _d : pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.author;
    function parseEntry(entry) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!('path' in entry)) {
            const theme = (_a = parseTheme(entry.theme, context, workspaceDir)) !== null && _a !== void 0 ? _a : themeIndexes[0];
            if (theme && themeIndexes.every((t) => t.location !== theme.location)) {
                themeIndexes.push(theme);
            }
            return {
                rel: 'contents',
                target: autoGeneratedTocPath,
                title: (_c = (_b = entry.title) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.tocTitle) !== null && _c !== void 0 ? _c : const_1.TOC_TITLE,
                theme,
            };
        }
        const sourcePath = upath_1.default.resolve(entryContextDir, entry.path); // abs
        const contextEntryPath = upath_1.default.relative(entryContextDir, sourcePath); // rel
        const targetPath = upath_1.default
            .resolve(workspaceDir, contextEntryPath)
            .replace(/\.md$/, '.html');
        const type = input_1.detectManuscriptMediaType(sourcePath);
        const metadata = parseFileMetadata(type, sourcePath, workspaceDir);
        const title = (_e = (_d = entry.title) !== null && _d !== void 0 ? _d : metadata.title) !== null && _e !== void 0 ? _e : projectTitle;
        const theme = (_g = (_f = parseTheme(entry.theme, context, workspaceDir)) !== null && _f !== void 0 ? _f : metadata.theme) !== null && _g !== void 0 ? _g : themeIndexes[0];
        if (theme && themeIndexes.every((t) => t.location !== theme.location)) {
            themeIndexes.push(theme);
        }
        return {
            type,
            source: sourcePath,
            target: targetPath,
            title,
            theme,
            ...(entry.rel && { rel: entry.rel }),
        };
    }
    const entries = (config === null || config === void 0 ? void 0 : config.entry)
        ? (Array.isArray(config.entry) ? config.entry : [config.entry])
            .map(normalizeEntry)
            .map(parseEntry)
        : [];
    if (!entries.length) {
        throw new Error('The entry fields seems to be empty. Make sure your Vivliostyle configuration.');
    }
    let fallbackProjectTitle = '';
    if (!projectTitle) {
        if (entries.length === 1 && entries[0].title) {
            fallbackProjectTitle = entries[0].title;
        }
        else {
            fallbackProjectTitle = upath_1.default.basename(outputs[0].path);
            util_1.log(`\n${chalk_1.default.yellow('Could not find any appropriate publication title. We set ')}${chalk_1.default.bold.yellow(`"${fallbackProjectTitle}"`)}${chalk_1.default.yellow(' as a fallback.')}`);
        }
    }
    if (!!(config === null || config === void 0 ? void 0 : config.toc) && !entries.find(({ rel }) => rel === 'contents')) {
        entries.unshift({
            rel: 'contents',
            target: autoGeneratedTocPath,
            title: (_e = config === null || config === void 0 ? void 0 : config.tocTitle) !== null && _e !== void 0 ? _e : const_1.TOC_TITLE,
            theme: themeIndexes[0],
        });
    }
    return {
        ...otherConfig,
        entries,
        input: {
            format: 'pub-manifest',
            entry: upath_1.default.join(workspaceDir, const_1.MANIFEST_FILENAME),
        },
        exportAliases: [],
        manifestPath: upath_1.default.join(workspaceDir, const_1.MANIFEST_FILENAME),
        manifestAutoGenerate: {
            title: projectTitle || fallbackProjectTitle,
            author: projectAuthor || '',
        },
    };
}
function checkUnusedCliFlags(config, cliFlags) {
    const unusedFlags = [];
    if (!config.manifestPath) {
        if (cliFlags.theme) {
            unusedFlags.push('--theme');
        }
        if (cliFlags.title) {
            unusedFlags.push('--title');
        }
        if (cliFlags.author) {
            unusedFlags.push('--author');
        }
        if (cliFlags.language) {
            unusedFlags.push('--language');
        }
    }
    if (unusedFlags.length) {
        util_1.log('\n');
        unusedFlags.forEach((flag) => {
            util_1.log(`${chalk_1.default.bold.yellow(flag)}${chalk_1.default.bold.yellow(` flag seems to be set but the current export setting doesn't support this. This option will be ignored.`)}`);
        });
    }
}
exports.checkUnusedCliFlags = checkUnusedCliFlags;
//# sourceMappingURL=config.js.map