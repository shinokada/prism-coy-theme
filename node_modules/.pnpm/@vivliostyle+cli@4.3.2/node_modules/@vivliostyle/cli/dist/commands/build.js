"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkUnsupportedOutputs = void 0;
const chalk_1 = __importDefault(require("chalk"));
const process_1 = __importDefault(require("process"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const upath_1 = __importDefault(require("upath"));
const browser_1 = require("../browser");
const builder_1 = require("../builder");
const config_1 = require("../config");
const container_1 = require("../container");
const pdf_1 = require("../pdf");
const util_1 = require("../util");
const webbook_1 = require("../webbook");
const build_parser_1 = require("./build.parser");
try {
    const program = build_parser_1.setupBuildParserProgram();
    program.parse(process_1.default.argv);
    const options = program.opts();
    build({
        input: (_a = program.args) === null || _a === void 0 ? void 0 : _a[0],
        configPath: options.config,
        targets: options.targets,
        theme: options.theme,
        size: options.size,
        style: options.style,
        userStyle: options.userStyle,
        singleDoc: options.singleDoc,
        title: options.title,
        author: options.author,
        language: options.language,
        pressReady: options.pressReady,
        renderMode: options.renderMode || 'local',
        preflight: options.preflight,
        preflightOption: options.preflightOption,
        verbose: options.verbose,
        timeout: options.timeout,
        sandbox: options.sandbox,
        executableChromium: options.executableChromium,
        image: options.image,
        bypassedPdfBuilderOption: options.bypassedPdfBuilderOption,
    }).catch(util_1.gracefulError);
}
catch (err) {
    util_1.gracefulError(err);
}
async function build(cliFlags) {
    var _a, _b, _c, _d;
    if (cliFlags.bypassedPdfBuilderOption) {
        const option = JSON.parse(cliFlags.bypassedPdfBuilderOption);
        // Host doesn't know inside path of chromium path
        option.executableChromium = browser_1.getExecutableBrowserPath();
        util_1.debug('bypassedPdfBuilderOption', option);
        await pdf_1.buildPDF(option);
        util_1.log();
        process_1.default.exit(0);
    }
    const isInContainer = container_1.checkContainerEnvironment();
    if (!isInContainer) {
        util_1.startLogging('Collecting build config');
    }
    const loadedConf = config_1.collectVivliostyleConfig(cliFlags);
    const { vivliostyleConfig, vivliostyleConfigPath } = loadedConf;
    cliFlags = loadedConf.cliFlags;
    const context = vivliostyleConfig ? upath_1.default.dirname(vivliostyleConfigPath) : util_1.cwd;
    const config = await config_1.mergeConfig(cliFlags, vivliostyleConfig, context);
    checkUnsupportedOutputs(config);
    // check output path not to overwrite source files
    for (const target of config.outputs) {
        builder_1.checkOverwriteViolation(config, target.path, target.format);
    }
    // build artifacts
    if (config.manifestPath) {
        await builder_1.compile(config);
        await builder_1.copyAssets(config);
    }
    // generate files
    for (const target of config.outputs) {
        let output = null;
        if (target.format === 'pdf') {
            if (!isInContainer && target.renderMode === 'docker') {
                output = await pdf_1.buildPDFWithContainer({
                    ...config,
                    input: ((_b = (_a = config.manifestPath) !== null && _a !== void 0 ? _a : config.webbookEntryPath) !== null && _b !== void 0 ? _b : config.epubOpfPath),
                    target,
                });
            }
            else {
                output = await pdf_1.buildPDF({
                    ...config,
                    input: ((_d = (_c = config.manifestPath) !== null && _c !== void 0 ? _c : config.webbookEntryPath) !== null && _d !== void 0 ? _d : config.epubOpfPath),
                    target,
                });
            }
        }
        else if (target.format === 'webpub') {
            if (!config.manifestPath) {
                continue;
            }
            output = await webbook_1.exportWebPublication({
                ...config,
                input: config.workspaceDir,
                output: target.path,
            });
        }
        if (output) {
            const formattedOutput = chalk_1.default.bold.green(upath_1.default.relative(util_1.cwd, output));
            util_1.log(`\n${terminal_link_1.default(formattedOutput, 'file://' + output, {
                fallback: () => formattedOutput,
            })} has been created.`);
        }
    }
    if (!isInContainer) {
        util_1.stopLogging('Built successfully.', 'ðŸŽ‰');
    }
    process_1.default.exit(0);
}
exports.default = build;
function checkUnsupportedOutputs({ webbookEntryPath, epubOpfPath, outputs, }) {
    if (webbookEntryPath && outputs.some((t) => t.format === 'webpub')) {
        throw new Error('Exporting webpub format from single HTML input is not supported.');
    }
    else if (epubOpfPath && outputs.some((t) => t.format === 'webpub')) {
        throw new Error('Exporting webpub format from EPUB or OPF file is not supported.');
    }
}
exports.checkUnsupportedOutputs = checkUnsupportedOutputs;
//# sourceMappingURL=build.js.map