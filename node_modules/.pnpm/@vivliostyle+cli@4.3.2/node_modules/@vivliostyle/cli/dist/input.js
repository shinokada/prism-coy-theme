"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectManuscriptMediaType = exports.manuscriptMediaTypes = exports.detectInputFormat = void 0;
const mime_types_1 = require("mime-types");
const upath_1 = __importDefault(require("upath"));
function detectInputFormat(entry) {
    const lowerCasedExt = upath_1.default.extname(entry).toLowerCase();
    if (lowerCasedExt === '.md' || lowerCasedExt === '.markdown') {
        return { format: 'markdown', entry };
    }
    else if (lowerCasedExt === '.json' || lowerCasedExt === '.jsonld') {
        return { format: 'pub-manifest', entry };
    }
    else if (lowerCasedExt === '.epub') {
        return { format: 'epub', entry };
    }
    else if (lowerCasedExt === '.opf') {
        return { format: 'epub-opf', entry };
    }
    else if (['.html', '.htm', '.xhtml', '.xht'].includes(lowerCasedExt)) {
        return { format: 'webbook', entry };
    }
    throw new Error(`Cannot find an input format for ${entry}`);
}
exports.detectInputFormat = detectInputFormat;
exports.manuscriptMediaTypes = [
    'text/markdown',
    'text/html',
    'application/xhtml+xml',
];
function detectManuscriptMediaType(entry) {
    const mediaType = mime_types_1.lookup(entry);
    if (exports.manuscriptMediaTypes.includes(mediaType)) {
        return mediaType;
    }
    throw new Error(`Invalid manuscript type ${mediaType} detected: ${entry}`);
}
exports.detectManuscriptMediaType = detectManuscriptMediaType;
//# sourceMappingURL=input.js.map