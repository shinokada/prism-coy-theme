"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkOverwriteViolation = exports.copyAssets = exports.compile = exports.generateManifest = exports.cleanup = void 0;
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const globby_1 = __importDefault(require("globby"));
const image_size_1 = require("image-size");
const mime_types_1 = require("mime-types");
const shelljs_1 = __importDefault(require("shelljs"));
const upath_1 = __importDefault(require("upath"));
const const_1 = require("./const");
const html_1 = require("./html");
const markdown_1 = require("./markdown");
const pubManifest_schema_1 = require("./schema/pubManifest.schema");
const util_1 = require("./util");
function cleanup(location) {
    util_1.debug('cleanup file', location);
    shelljs_1.default.rm('-rf', location);
}
exports.cleanup = cleanup;
// https://www.w3.org/TR/pub-manifest/
function generateManifest(outputPath, entryContextDir, options) {
    const entries = options.entries.map((entry) => ({
        url: encodeURI(entry.path),
        title: entry.title,
        ...(entry.encodingFormat && { encodingFormat: entry.encodingFormat }),
        ...(entry.rel && { rel: entry.rel }),
        ...(entry.rel === 'contents' && { type: 'LinkedResource' }),
    }));
    const links = [];
    const resources = [];
    if (options.cover) {
        const { width, height, type } = image_size_1.imageSize(upath_1.default.resolve(entryContextDir, options.cover));
        let mimeType = false;
        if (type) {
            mimeType = mime_types_1.lookup(type);
            if (mimeType) {
                links.push({
                    rel: 'cover',
                    url: encodeURI(options.cover),
                    encodingFormat: mimeType,
                    width,
                    height,
                });
            }
        }
        if (!type || !mimeType) {
            util_1.log(`\n${chalk_1.default.yellow('Cover image ')}${chalk_1.default.bold.yellow(`"${options.cover}"`)}${chalk_1.default.yellow(' was set in your configuration but couldnâ€™t detect the image metadata. Please check a valid cover file is placed.')}`);
        }
    }
    const publication = {
        '@context': ['https://schema.org', 'https://www.w3.org/ns/pub-context'],
        type: 'Book',
        conformsTo: 'https://github.com/vivliostyle/vivliostyle-cli',
        author: options.author,
        ...(options.language && { inLanguage: options.language }),
        dateModified: options.modified,
        name: options.title,
        readingOrder: entries,
        resources,
        links,
    };
    fs_1.default.writeFileSync(outputPath, JSON.stringify(publication, null, 2));
    const ajv = new ajv_1.default({ strict: false });
    ajv_formats_1.default(ajv);
    ajv.addSchema(pubManifest_schema_1.publicationSchemas);
    const valid = ajv.validate(pubManifest_schema_1.publicationSchemaId, publication);
    if (!valid) {
        throw new Error(`Validation of pubManifest failed. Please check the schema: ${outputPath}`);
    }
}
exports.generateManifest = generateManifest;
async function compile({ entryContextDir, workspaceDir, manifestPath, manifestAutoGenerate, themeIndexes, entries, language, cover, vfmOptions, input, }, { reload = false } = {}) {
    var _a;
    util_1.debug('entries', entries);
    util_1.debug('themes', themeIndexes);
    if (!reload && !util_1.pathStartsWith(entryContextDir, workspaceDir)) {
        // workspaceDir is placed on different directory
        cleanup(workspaceDir);
    }
    const locateThemePath = (from, theme) => {
        switch (theme === null || theme === void 0 ? void 0 : theme.type) {
            case 'uri':
                return theme.location;
            case 'file':
                return upath_1.default.relative(from, theme.destination);
            case 'package':
                return upath_1.default.relative(from, upath_1.default.join(theme.destination, theme.style));
        }
    };
    const generativeContentsEntry = entries.find((e) => !('source' in e) && e.rel === 'contents');
    if (generativeContentsEntry &&
        fs_1.default.existsSync(generativeContentsEntry.target) &&
        !html_1.isTocHtml(generativeContentsEntry.target)) {
        throw new Error(`${generativeContentsEntry.target} is set as a destination to create a ToC HTML file, but there is already a document other than the ToC file in this location. Please move this file, or set a 'toc' option in vivliostyle.config.js to specify another destination for the ToC file.`);
    }
    const contentEntries = entries.filter((e) => 'source' in e);
    for (const entry of contentEntries) {
        shelljs_1.default.mkdir('-p', upath_1.default.dirname(entry.target));
        // calculate style path
        const style = locateThemePath(upath_1.default.dirname(entry.target), entry.theme);
        if (entry.type === 'text/markdown') {
            // compile markdown
            const vfile = markdown_1.processMarkdown(entry.source, {
                ...vfmOptions,
                style,
                title: entry.title,
                language: language !== null && language !== void 0 ? language : undefined,
            });
            const compiledEntry = String(vfile);
            fs_1.default.writeFileSync(entry.target, compiledEntry);
        }
        else if (entry.type === 'text/html' ||
            entry.type === 'application/xhtml+xml') {
            if (entry.source !== entry.target) {
                const html = html_1.processManuscriptHtml(entry.source, {
                    style,
                    title: entry.title,
                    contentType: entry.type,
                    language,
                });
                fs_1.default.writeFileSync(entry.target, html);
            }
        }
        else {
            if (entry.source !== entry.target) {
                shelljs_1.default.cp(entry.source, entry.target);
            }
        }
    }
    // copy theme
    for (const theme of themeIndexes) {
        if (theme.type === 'file') {
            if (theme.location !== theme.destination) {
                shelljs_1.default.mkdir('-p', upath_1.default.dirname(theme.destination));
                shelljs_1.default.cp(theme.location, theme.destination);
            }
        }
        else if (theme.type === 'package') {
            shelljs_1.default.mkdir('-p', theme.destination);
            shelljs_1.default.cp('-r', upath_1.default.join(theme.location, '*'), theme.destination);
        }
    }
    // generate toc
    if (generativeContentsEntry) {
        const style = locateThemePath(workspaceDir, generativeContentsEntry.theme);
        const tocString = html_1.generateTocHtml({
            entries: contentEntries,
            manifestPath,
            distDir: upath_1.default.dirname(generativeContentsEntry.target),
            title: manifestAutoGenerate === null || manifestAutoGenerate === void 0 ? void 0 : manifestAutoGenerate.title,
            tocTitle: (_a = generativeContentsEntry.title) !== null && _a !== void 0 ? _a : const_1.TOC_TITLE,
            style,
        });
        fs_1.default.writeFileSync(generativeContentsEntry.target, tocString);
    }
    // generate manifest
    if (manifestAutoGenerate) {
        generateManifest(manifestPath, entryContextDir, {
            ...manifestAutoGenerate,
            language,
            cover: cover && upath_1.default.relative(entryContextDir, cover),
            entries: entries.map((entry) => ({
                title: entry.title,
                path: upath_1.default.relative(workspaceDir, entry.target),
                encodingFormat: !('type' in entry) ||
                    entry.type === 'text/markdown' ||
                    entry.type === 'text/html'
                    ? undefined
                    : entry.type,
                rel: entry.rel,
            })),
            modified: new Date().toISOString(),
        });
    }
}
exports.compile = compile;
async function copyAssets({ entryContextDir, workspaceDir, includeAssets, }) {
    if (entryContextDir === workspaceDir) {
        return;
    }
    const relWorkspaceDir = upath_1.default.relative(entryContextDir, workspaceDir);
    const assets = await globby_1.default(includeAssets, {
        cwd: entryContextDir,
        ignore: relWorkspaceDir ? [upath_1.default.join(relWorkspaceDir, '**/*')] : undefined,
        caseSensitiveMatch: false,
        followSymbolicLinks: false,
        gitignore: true,
    });
    util_1.debug('assets', assets);
    for (const asset of assets) {
        const target = upath_1.default.join(workspaceDir, asset);
        shelljs_1.default.mkdir('-p', upath_1.default.dirname(target));
        shelljs_1.default.cp(upath_1.default.resolve(entryContextDir, asset), target);
    }
}
exports.copyAssets = copyAssets;
function checkOverwriteViolation({ entryContextDir, workspaceDir }, target, fileInformation) {
    if (util_1.pathStartsWith(entryContextDir, target)) {
        throw new Error(`${target} is set as output destination of ${fileInformation}, however, this output path will overwrite the manuscript file(s). Please specify other paths.`);
    }
    if (util_1.pathStartsWith(workspaceDir, target)) {
        throw new Error(`${target} is set as output destination of ${fileInformation}, however, this output path will overwrite the working directory of Vivliostyle. Please specify other paths.`);
    }
}
exports.checkOverwriteViolation = checkOverwriteViolation;
//# sourceMappingURL=builder.js.map