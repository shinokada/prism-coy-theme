"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPDF = exports.buildPDFWithContainer = void 0;
const chalk_1 = __importDefault(require("chalk"));
const shelljs_1 = __importDefault(require("shelljs"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const upath_1 = __importDefault(require("upath"));
const url_1 = require("url");
const browser_1 = require("./browser");
const container_1 = require("./container");
const postprocess_1 = require("./postprocess");
const server_1 = require("./server");
const util_1 = require("./util");
async function buildPDFWithContainer(option) {
    const bypassedOption = {
        ...option,
        input: container_1.toContainerPath(option.input),
        target: {
            ...option.target,
            path: container_1.toContainerPath(option.target.path),
        },
        entryContextDir: container_1.toContainerPath(option.entryContextDir),
        workspaceDir: container_1.toContainerPath(option.workspaceDir),
        customStyle: option.customStyle && container_1.toContainerPath(option.customStyle),
        customUserStyle: option.customUserStyle && container_1.toContainerPath(option.customUserStyle),
        sandbox: false,
    };
    await container_1.runContainer({
        image: option.image,
        userVolumeArgs: container_1.collectVolumeArgs([
            option.workspaceDir,
            upath_1.default.dirname(option.target.path),
        ]),
        commandArgs: [
            'build',
            '--bypassed-pdf-builder-option',
            JSON.stringify(bypassedOption),
        ],
    });
    return option.target.path;
}
exports.buildPDFWithContainer = buildPDFWithContainer;
async function buildPDF({ input, target, workspaceDir, size, customStyle, customUserStyle, singleDoc, executableChromium, image, sandbox, verbose, timeout, entryContextDir, entries, }) {
    const isInContainer = container_1.checkContainerEnvironment();
    util_1.logUpdate(`Launching build environment`);
    const navigateURL = server_1.getBrokerUrl({
        sourceIndex: input,
        outputSize: size,
        style: customStyle,
        userStyle: customUserStyle,
        singleDoc,
        quick: false,
    });
    util_1.debug('brokerURL', navigateURL);
    util_1.debug(`Executing Chromium path: ${executableChromium}`);
    if (!browser_1.checkBrowserAvailability(executableChromium)) {
        const puppeteerDir = upath_1.default.dirname(require.resolve('puppeteer-core/package.json'));
        if (!upath_1.default.relative(puppeteerDir, executableChromium).startsWith('..')) {
            // The browser on puppeteer-core isn't downloaded first time starting CLI so try to download it
            await browser_1.downloadBrowser();
        }
        else {
            // executableChromium seems to be specified explicitly
            throw new Error(`Cannot find the browser. Please check the executable chromium path: ${executableChromium}`);
        }
    }
    const browser = await browser_1.launchBrowser({
        headless: true,
        executablePath: executableChromium,
        args: [
            '--allow-file-access-from-files',
            // FIXME: We seem have to disable sandbox now
            // https://github.com/vivliostyle/vivliostyle-cli/issues/186
            sandbox ? '' : '--no-sandbox',
            '--disable-web-security',
            isInContainer ? '--disable-dev-shm-usage' : '',
        ],
    });
    const version = await browser.version();
    util_1.debug(chalk_1.default.green('success'), `version=${version}`);
    util_1.logUpdate('Building pages');
    // FIXME: This issue was reported but all workaround didn't fix
    // https://github.com/puppeteer/puppeteer/issues/4039
    await new Promise((res) => setTimeout(res, 1000));
    const page = await browser.newPage();
    page.on('pageerror', (error) => {
        util_1.logError(chalk_1.default.red(error.message));
    });
    page.on('console', (msg) => {
        var _a;
        switch (msg.type()) {
            case 'error':
                if (/\/vivliostyle-viewer\.js$/.test((_a = msg.location().url) !== null && _a !== void 0 ? _a : '')) {
                    util_1.logError(msg.text());
                    throw msg.text();
                }
                return;
            case 'debug':
                if (/time slice/.test(msg.text())) {
                    return;
                }
                break;
        }
        if (!verbose) {
            return;
        }
        if (msg.type() === 'error') {
            util_1.logError(msg.text());
        }
        else {
            util_1.logInfo(msg.text());
        }
    });
    let lastEntry;
    function stringifyEntry(entry) {
        const formattedSourcePath = chalk_1.default.bold.cyan(upath_1.default.relative(entryContextDir, entry.source));
        return `${terminal_link_1.default(formattedSourcePath, 'file://' + entry.source, {
            fallback: () => formattedSourcePath,
        })} ${entry.title ? chalk_1.default.gray(entry.title) : ''}`;
    }
    function handleEntry(response) {
        const entry = entries.find((entry) => {
            if (!('source' in entry)) {
                return false;
            }
            const url = new url_1.URL(response.url());
            return url.protocol === 'file:'
                ? entry.target === url.pathname
                : upath_1.default.relative(workspaceDir, entry.target) ===
                    url.pathname.substring(1);
        });
        if (entry) {
            if (!lastEntry) {
                lastEntry = entry;
                return util_1.logUpdate(stringifyEntry(entry));
            }
            util_1.logSuccess(stringifyEntry(lastEntry));
            util_1.startLogging(stringifyEntry(entry));
            lastEntry = entry;
        }
    }
    page.on('response', (response) => {
        util_1.debug(chalk_1.default.gray('broker:response'), chalk_1.default.green(response.status().toString()), response.url());
        handleEntry(response);
        if (300 > response.status() && 200 <= response.status())
            return;
        // file protocol doesn't have status code
        if (response.url().startsWith('file://') && response.ok())
            return;
        util_1.logError(chalk_1.default.red(`${response.status()}`, response.url()));
        util_1.startLogging();
        // debug(chalk.red(`${response.status()}`, response.url()));
    });
    await page.setDefaultNavigationTimeout(timeout);
    await page.goto(navigateURL, { waitUntil: 'networkidle0' });
    await page.waitForFunction(() => !!window.coreViewer);
    await page.emulateMediaType('print');
    await page.waitForFunction(() => window.coreViewer.readyState === 'complete', {
        polling: 1000,
        timeout,
    });
    if (lastEntry) {
        util_1.logSuccess(stringifyEntry(lastEntry));
    }
    const metadata = await loadMetadata(page);
    const toc = await loadTOC(page);
    util_1.startLogging('Building PDF');
    const pdf = await page.pdf({
        margin: {
            top: 0,
            bottom: 0,
            right: 0,
            left: 0,
        },
        printBackground: true,
        preferCSSPageSize: true,
    });
    await browser.close();
    util_1.logUpdate('Processing PDF');
    shelljs_1.default.mkdir('-p', upath_1.default.dirname(target.path));
    const post = await postprocess_1.PostProcess.load(pdf);
    await post.metadata(metadata);
    await post.toc(toc);
    await post.save(target.path, {
        preflight: target.preflight,
        preflightOption: target.preflightOption,
        image,
    });
    return target.path;
}
exports.buildPDF = buildPDF;
async function loadMetadata(page) {
    return page.evaluate(() => window.coreViewer.getMetadata());
}
// Show and hide the TOC in order to read its contents.
// Chromium needs to see the TOC links in the DOM to add
// the PDF destinations used during postprocessing.
async function loadTOC(page) {
    return page.evaluate(() => new Promise((resolve) => {
        function listener(payload) {
            if (payload.a !== 'toc') {
                return;
            }
            window.coreViewer.removeListener('done', listener);
            window.coreViewer.showTOC(false);
            resolve(window.coreViewer.getTOC());
        }
        window.coreViewer.addListener('done', listener);
        window.coreViewer.showTOC(true);
    }));
}
//# sourceMappingURL=pdf.js.map